## disruptor的handler的串行和并行测试

### 基于入门的样例进行测试

> OrderEventHandler.java
```java
package com.njust.disruptor;

import com.lmax.disruptor.EventHandler;

import java.util.Date;

public class OrderEventHandler implements EventHandler<OrderEvent> {
    @Override
    public void onEvent(OrderEvent event, long sequence, boolean endOfBatch) throws Exception {
        System.out.println(new Date() + ":OrderEventHandler ==>");
        Thread.sleep(5 * 1000);
        System.out.println(new Date() + ":OrderEventHandler ==> end");
    }
}
```

> OrderEventHandler222.java
```java
package com.njust.disruptor;

import com.lmax.disruptor.EventHandler;

import java.util.Date;

public class OrderEventHandler222 implements EventHandler<OrderEvent> {
    @Override
    public void onEvent(OrderEvent event, long sequence, boolean endOfBatch) throws Exception {
        System.out.println(new Date() + "OrderEventHandler222 ==>");
        System.out.println(new Date() + "OrderEventHandler222 ==> end");
    }
}
```

```java
package com.njust.disruptor;

import com.lmax.disruptor.RingBuffer;
import com.lmax.disruptor.SleepingWaitStrategy;
import com.lmax.disruptor.dsl.Disruptor;
import com.lmax.disruptor.dsl.ProducerType;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class DisruptorDemo {

    //bufferSize must be a power of 2
    //2 * 2^n = 2 <<n
    private static final int BUFFER_SIZE = 2 << 9;

    public static void main(String[] args) {


        // 消费者线程池
        ExecutorService executorService = Executors.newCachedThreadPool();
        // 事件工厂
        OrderEventFactory eventFactory = new OrderEventFactory();
        Disruptor<OrderEvent> disruptor = new Disruptor<>(eventFactory, BUFFER_SIZE, executorService,
                ProducerType.SINGLE, new SleepingWaitStrategy());
         
        //！！！主要看这里的区别 
        disruptor.handleEventsWith(new OrderEventHandler());
        disruptor.handleEventsWith(new OrderEventHandler222());

        disruptor.start();

        //生产者
        RingBuffer<OrderEvent> ringBuffer = disruptor.getRingBuffer();
        OrderEventProducer orderEventProducer = new OrderEventProducer(ringBuffer);

        orderEventProducer.onData(100);
    }


}
```

### 串行和并行测试

> 并发
```java
disruptor.handleEventsWith(new OrderEventHandler());
disruptor.handleEventsWith(new OrderEventHandler222());
```

```console
Tue Nov 21 11:37:13 CST 2023:OrderEventHandler ==>
Tue Nov 21 11:37:13 CST 2023OrderEventHandler222 ==>
Tue Nov 21 11:37:13 CST 2023OrderEventHandler222 ==> end
Tue Nov 21 11:37:18 CST 2023:OrderEventHandler ==> end
```

> 并发

```java
 disruptor.handleEventsWith(new OrderEventHandler(), new OrderEventHandler222());
```

```console
Tue Nov 21 11:48:51 CST 2023OrderEventHandler222 ==>
Tue Nov 21 11:48:51 CST 2023:OrderEventHandler ==>
Tue Nov 21 11:48:51 CST 2023OrderEventHandler222 ==> end
Tue Nov 21 11:48:56 CST 2023:OrderEventHandler ==> end
```

>串行

```java
disruptor.handleEventsWith(new OrderEventHandler()).handleEventsWith(new OrderEventHandler222());
```

```console
Tue Nov 21 11:50:46 CST 2023:OrderEventHandler ==>
Tue Nov 21 11:50:51 CST 2023:OrderEventHandler ==> end
Tue Nov 21 11:50:51 CST 2023OrderEventHandler222 ==>
Tue Nov 21 11:50:51 CST 2023OrderEventHandler222 ==> end
```

> 串行

> 从源码看，`.handleEventsWith`和`.then`没区别
> ![image](https://github.com/GenweiWu/Blog/assets/16630659/fd5b0661-41ff-433f-8b0f-b2bb4fb66e99)


```java
disruptor.handleEventsWith(new OrderEventHandler()).then(new OrderEventHandler222());
```

```console
Tue Nov 21 11:51:44 CST 2023:OrderEventHandler ==>
Tue Nov 21 11:51:49 CST 2023:OrderEventHandler ==> end
Tue Nov 21 11:51:49 CST 2023OrderEventHandler222 ==>
Tue Nov 21 11:51:49 CST 2023OrderEventHandler222 ==> end
```

### 更多情况
> https://www.javaedit.com/archives/198




