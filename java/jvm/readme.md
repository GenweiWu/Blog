## JVM基础概念
[参考: JVM基础知识](https://blog.csdn.net/ithomer/article/details/9936743)


## 堆栈
- stack：栈
- heap：堆
堆中存的是对象。栈中存的是基本数据类型和堆中对象的引用。一个对象的大小是不可估计的，或者说是可以动态变化的，但是在栈中，一个对象只对应了一个4byte的引用（堆栈分离的好处）


## 基本GC算法
- 标记-清除 
标记出所有需要回收的对象，然后统一清除
但是需要暂停应用，且会产生内存碎片
(适合剩下很多，比如老年代)

- 复制 
把内存空间分为两部分，每次使用其中一个，垃圾回收时将其中还在使用的对象，复制到另一个中
复制后会进行类似内存整理，不会出现碎片；但是需要两倍的空间
( 适合每次清理很多，复制很少，如新生代)

- 标记-整理 
标记出所有需要回收的对象，然后清除不再使用的对象，再进行内存整理
既可以避免 标记-清除的碎片问题，也能避免两倍空间的问题
( 适合剩下很多，比如老年代)

## 主要的内存空间
#### 1.新生代
- Eden Space 任何新进入运行时数据区域的实例都会存放在此

- S0 Suvivor Space 存在时间较长，经过垃圾回收没有被清除的实例，就从Eden 搬到了S0

- S1 Survivor Space 同理，存在时间更长的实例，就从S0 搬到了S1

#### 2.年老代
存在时间更长的实例，对象多次回收没被清除，就从S1 搬到了tenured

#### 3.持久代 Perm
存放运行时数据区和方法区；用于存放静态文件，如Java类、方法等，持久代对垃圾回收没有显著影响
持久代大小通过-XX:MaxPermSize=<N>进行设置

![image](https://user-images.githubusercontent.com/16630659/43237903-75513926-90be-11e8-8347-055d646712f4.png)

## 何时会触发GC
1. 老年代空间不足
2. 持久代/方法区空间不足
3. 上几次晋升对象的平均大小超过年老代空闲大小
  - Minor GC后进入老年代的平均大小>老年代的可用内存大小
  - 由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小
4. 人为触发System.gc，但是不是必然执行
5. MaxDirectMemeorySize超过，堆外内存不足导致的Full GC




